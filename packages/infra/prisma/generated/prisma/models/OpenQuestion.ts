/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `OpenQuestion` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client';
import type * as $Enums from '../enums.ts';
import type * as Prisma from '../internal/prismaNamespace.ts';

/**
 * Model OpenQuestion
 *
 */
export type OpenQuestionModel = runtime.Types.Result.DefaultSelection<Prisma.$OpenQuestionPayload>;

export type AggregateOpenQuestion = {
  _count: OpenQuestionCountAggregateOutputType | null;
  _min: OpenQuestionMinAggregateOutputType | null;
  _max: OpenQuestionMaxAggregateOutputType | null;
};

export type OpenQuestionMinAggregateOutputType = {
  id: string | null;
  clientId: string | null;
  meetingId: string | null;
  assigneeId: string | null;
  resolvedByDecisionId: string | null;
  question: string | null;
  context: string | null;
  status: $Enums.OpenQuestionStatus | null;
  dueAt: Date | null;
  createdAt: Date | null;
  resolvedAt: Date | null;
};

export type OpenQuestionMaxAggregateOutputType = {
  id: string | null;
  clientId: string | null;
  meetingId: string | null;
  assigneeId: string | null;
  resolvedByDecisionId: string | null;
  question: string | null;
  context: string | null;
  status: $Enums.OpenQuestionStatus | null;
  dueAt: Date | null;
  createdAt: Date | null;
  resolvedAt: Date | null;
};

export type OpenQuestionCountAggregateOutputType = {
  id: number;
  clientId: number;
  meetingId: number;
  assigneeId: number;
  resolvedByDecisionId: number;
  question: number;
  context: number;
  status: number;
  dueAt: number;
  createdAt: number;
  resolvedAt: number;
  _all: number;
};

export type OpenQuestionMinAggregateInputType = {
  id?: true;
  clientId?: true;
  meetingId?: true;
  assigneeId?: true;
  resolvedByDecisionId?: true;
  question?: true;
  context?: true;
  status?: true;
  dueAt?: true;
  createdAt?: true;
  resolvedAt?: true;
};

export type OpenQuestionMaxAggregateInputType = {
  id?: true;
  clientId?: true;
  meetingId?: true;
  assigneeId?: true;
  resolvedByDecisionId?: true;
  question?: true;
  context?: true;
  status?: true;
  dueAt?: true;
  createdAt?: true;
  resolvedAt?: true;
};

export type OpenQuestionCountAggregateInputType = {
  id?: true;
  clientId?: true;
  meetingId?: true;
  assigneeId?: true;
  resolvedByDecisionId?: true;
  question?: true;
  context?: true;
  status?: true;
  dueAt?: true;
  createdAt?: true;
  resolvedAt?: true;
  _all?: true;
};

export type OpenQuestionAggregateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which OpenQuestion to aggregate.
   */
  where?: Prisma.OpenQuestionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of OpenQuestions to fetch.
   */
  orderBy?:
    | Prisma.OpenQuestionOrderByWithRelationInput
    | Prisma.OpenQuestionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.OpenQuestionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` OpenQuestions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` OpenQuestions.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned OpenQuestions
   **/
  _count?: true | OpenQuestionCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: OpenQuestionMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: OpenQuestionMaxAggregateInputType;
};

export type GetOpenQuestionAggregateType<T extends OpenQuestionAggregateArgs> = {
  [P in keyof T & keyof AggregateOpenQuestion]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateOpenQuestion[P]>
    : Prisma.GetScalarType<T[P], AggregateOpenQuestion[P]>;
};

export type OpenQuestionGroupByArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.OpenQuestionWhereInput;
  orderBy?:
    | Prisma.OpenQuestionOrderByWithAggregationInput
    | Prisma.OpenQuestionOrderByWithAggregationInput[];
  by: Prisma.OpenQuestionScalarFieldEnum[] | Prisma.OpenQuestionScalarFieldEnum;
  having?: Prisma.OpenQuestionScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: OpenQuestionCountAggregateInputType | true;
  _min?: OpenQuestionMinAggregateInputType;
  _max?: OpenQuestionMaxAggregateInputType;
};

export type OpenQuestionGroupByOutputType = {
  id: string;
  clientId: string;
  meetingId: string | null;
  assigneeId: string | null;
  resolvedByDecisionId: string | null;
  question: string;
  context: string | null;
  status: $Enums.OpenQuestionStatus;
  dueAt: Date | null;
  createdAt: Date;
  resolvedAt: Date | null;
  _count: OpenQuestionCountAggregateOutputType | null;
  _min: OpenQuestionMinAggregateOutputType | null;
  _max: OpenQuestionMaxAggregateOutputType | null;
};

type GetOpenQuestionGroupByPayload<T extends OpenQuestionGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<OpenQuestionGroupByOutputType, T['by']> & {
      [P in keyof T & keyof OpenQuestionGroupByOutputType]: P extends '_count'
        ? T[P] extends boolean
          ? number
          : Prisma.GetScalarType<T[P], OpenQuestionGroupByOutputType[P]>
        : Prisma.GetScalarType<T[P], OpenQuestionGroupByOutputType[P]>;
    }
  >
>;

export type OpenQuestionWhereInput = {
  AND?: Prisma.OpenQuestionWhereInput | Prisma.OpenQuestionWhereInput[];
  OR?: Prisma.OpenQuestionWhereInput[];
  NOT?: Prisma.OpenQuestionWhereInput | Prisma.OpenQuestionWhereInput[];
  id?: Prisma.StringFilter<'OpenQuestion'> | string;
  clientId?: Prisma.StringFilter<'OpenQuestion'> | string;
  meetingId?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
  assigneeId?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
  resolvedByDecisionId?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
  question?: Prisma.StringFilter<'OpenQuestion'> | string;
  context?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
  status?: Prisma.EnumOpenQuestionStatusFilter<'OpenQuestion'> | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.DateTimeNullableFilter<'OpenQuestion'> | Date | string | null;
  createdAt?: Prisma.DateTimeFilter<'OpenQuestion'> | Date | string;
  resolvedAt?: Prisma.DateTimeNullableFilter<'OpenQuestion'> | Date | string | null;
  client?: Prisma.XOR<Prisma.ClientScalarRelationFilter, Prisma.ClientWhereInput>;
  meeting?: Prisma.XOR<Prisma.MeetingNullableScalarRelationFilter, Prisma.MeetingWhereInput> | null;
  assignee?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null;
  resolvedByDecision?: Prisma.XOR<
    Prisma.DecisionNullableScalarRelationFilter,
    Prisma.DecisionWhereInput
  > | null;
};

export type OpenQuestionOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  clientId?: Prisma.SortOrder;
  meetingId?: Prisma.SortOrderInput | Prisma.SortOrder;
  assigneeId?: Prisma.SortOrderInput | Prisma.SortOrder;
  resolvedByDecisionId?: Prisma.SortOrderInput | Prisma.SortOrder;
  question?: Prisma.SortOrder;
  context?: Prisma.SortOrderInput | Prisma.SortOrder;
  status?: Prisma.SortOrder;
  dueAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  resolvedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  client?: Prisma.ClientOrderByWithRelationInput;
  meeting?: Prisma.MeetingOrderByWithRelationInput;
  assignee?: Prisma.UserOrderByWithRelationInput;
  resolvedByDecision?: Prisma.DecisionOrderByWithRelationInput;
};

export type OpenQuestionWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string;
    AND?: Prisma.OpenQuestionWhereInput | Prisma.OpenQuestionWhereInput[];
    OR?: Prisma.OpenQuestionWhereInput[];
    NOT?: Prisma.OpenQuestionWhereInput | Prisma.OpenQuestionWhereInput[];
    clientId?: Prisma.StringFilter<'OpenQuestion'> | string;
    meetingId?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
    assigneeId?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
    resolvedByDecisionId?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
    question?: Prisma.StringFilter<'OpenQuestion'> | string;
    context?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
    status?: Prisma.EnumOpenQuestionStatusFilter<'OpenQuestion'> | $Enums.OpenQuestionStatus;
    dueAt?: Prisma.DateTimeNullableFilter<'OpenQuestion'> | Date | string | null;
    createdAt?: Prisma.DateTimeFilter<'OpenQuestion'> | Date | string;
    resolvedAt?: Prisma.DateTimeNullableFilter<'OpenQuestion'> | Date | string | null;
    client?: Prisma.XOR<Prisma.ClientScalarRelationFilter, Prisma.ClientWhereInput>;
    meeting?: Prisma.XOR<
      Prisma.MeetingNullableScalarRelationFilter,
      Prisma.MeetingWhereInput
    > | null;
    assignee?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null;
    resolvedByDecision?: Prisma.XOR<
      Prisma.DecisionNullableScalarRelationFilter,
      Prisma.DecisionWhereInput
    > | null;
  },
  'id'
>;

export type OpenQuestionOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  clientId?: Prisma.SortOrder;
  meetingId?: Prisma.SortOrderInput | Prisma.SortOrder;
  assigneeId?: Prisma.SortOrderInput | Prisma.SortOrder;
  resolvedByDecisionId?: Prisma.SortOrderInput | Prisma.SortOrder;
  question?: Prisma.SortOrder;
  context?: Prisma.SortOrderInput | Prisma.SortOrder;
  status?: Prisma.SortOrder;
  dueAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  resolvedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
  _count?: Prisma.OpenQuestionCountOrderByAggregateInput;
  _max?: Prisma.OpenQuestionMaxOrderByAggregateInput;
  _min?: Prisma.OpenQuestionMinOrderByAggregateInput;
};

export type OpenQuestionScalarWhereWithAggregatesInput = {
  AND?:
    | Prisma.OpenQuestionScalarWhereWithAggregatesInput
    | Prisma.OpenQuestionScalarWhereWithAggregatesInput[];
  OR?: Prisma.OpenQuestionScalarWhereWithAggregatesInput[];
  NOT?:
    | Prisma.OpenQuestionScalarWhereWithAggregatesInput
    | Prisma.OpenQuestionScalarWhereWithAggregatesInput[];
  id?: Prisma.StringWithAggregatesFilter<'OpenQuestion'> | string;
  clientId?: Prisma.StringWithAggregatesFilter<'OpenQuestion'> | string;
  meetingId?: Prisma.StringNullableWithAggregatesFilter<'OpenQuestion'> | string | null;
  assigneeId?: Prisma.StringNullableWithAggregatesFilter<'OpenQuestion'> | string | null;
  resolvedByDecisionId?: Prisma.StringNullableWithAggregatesFilter<'OpenQuestion'> | string | null;
  question?: Prisma.StringWithAggregatesFilter<'OpenQuestion'> | string;
  context?: Prisma.StringNullableWithAggregatesFilter<'OpenQuestion'> | string | null;
  status?:
    | Prisma.EnumOpenQuestionStatusWithAggregatesFilter<'OpenQuestion'>
    | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.DateTimeNullableWithAggregatesFilter<'OpenQuestion'> | Date | string | null;
  createdAt?: Prisma.DateTimeWithAggregatesFilter<'OpenQuestion'> | Date | string;
  resolvedAt?: Prisma.DateTimeNullableWithAggregatesFilter<'OpenQuestion'> | Date | string | null;
};

export type OpenQuestionCreateInput = {
  id?: string;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
  client: Prisma.ClientCreateNestedOneWithoutOpenQuestionsInput;
  meeting?: Prisma.MeetingCreateNestedOneWithoutOpenQuestionsInput;
  assignee?: Prisma.UserCreateNestedOneWithoutAssignedQuestionsInput;
  resolvedByDecision?: Prisma.DecisionCreateNestedOneWithoutResolvedQuestionsInput;
};

export type OpenQuestionUncheckedCreateInput = {
  id?: string;
  clientId: string;
  meetingId?: string | null;
  assigneeId?: string | null;
  resolvedByDecisionId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  client?: Prisma.ClientUpdateOneRequiredWithoutOpenQuestionsNestedInput;
  meeting?: Prisma.MeetingUpdateOneWithoutOpenQuestionsNestedInput;
  assignee?: Prisma.UserUpdateOneWithoutAssignedQuestionsNestedInput;
  resolvedByDecision?: Prisma.DecisionUpdateOneWithoutResolvedQuestionsNestedInput;
};

export type OpenQuestionUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  clientId?: Prisma.StringFieldUpdateOperationsInput | string;
  meetingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  assigneeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  resolvedByDecisionId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionCreateManyInput = {
  id?: string;
  clientId: string;
  meetingId?: string | null;
  assigneeId?: string | null;
  resolvedByDecisionId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  clientId?: Prisma.StringFieldUpdateOperationsInput | string;
  meetingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  assigneeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  resolvedByDecisionId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionListRelationFilter = {
  every?: Prisma.OpenQuestionWhereInput;
  some?: Prisma.OpenQuestionWhereInput;
  none?: Prisma.OpenQuestionWhereInput;
};

export type OpenQuestionOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder;
};

export type OpenQuestionCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  clientId?: Prisma.SortOrder;
  meetingId?: Prisma.SortOrder;
  assigneeId?: Prisma.SortOrder;
  resolvedByDecisionId?: Prisma.SortOrder;
  question?: Prisma.SortOrder;
  context?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  dueAt?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  resolvedAt?: Prisma.SortOrder;
};

export type OpenQuestionMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  clientId?: Prisma.SortOrder;
  meetingId?: Prisma.SortOrder;
  assigneeId?: Prisma.SortOrder;
  resolvedByDecisionId?: Prisma.SortOrder;
  question?: Prisma.SortOrder;
  context?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  dueAt?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  resolvedAt?: Prisma.SortOrder;
};

export type OpenQuestionMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  clientId?: Prisma.SortOrder;
  meetingId?: Prisma.SortOrder;
  assigneeId?: Prisma.SortOrder;
  resolvedByDecisionId?: Prisma.SortOrder;
  question?: Prisma.SortOrder;
  context?: Prisma.SortOrder;
  status?: Prisma.SortOrder;
  dueAt?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  resolvedAt?: Prisma.SortOrder;
};

export type OpenQuestionCreateNestedManyWithoutClientInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutClientInput,
        Prisma.OpenQuestionUncheckedCreateWithoutClientInput
      >
    | Prisma.OpenQuestionCreateWithoutClientInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutClientInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutClientInput
    | Prisma.OpenQuestionCreateOrConnectWithoutClientInput[];
  createMany?: Prisma.OpenQuestionCreateManyClientInputEnvelope;
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
};

export type OpenQuestionUncheckedCreateNestedManyWithoutClientInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutClientInput,
        Prisma.OpenQuestionUncheckedCreateWithoutClientInput
      >
    | Prisma.OpenQuestionCreateWithoutClientInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutClientInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutClientInput
    | Prisma.OpenQuestionCreateOrConnectWithoutClientInput[];
  createMany?: Prisma.OpenQuestionCreateManyClientInputEnvelope;
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
};

export type OpenQuestionUpdateManyWithoutClientNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutClientInput,
        Prisma.OpenQuestionUncheckedCreateWithoutClientInput
      >
    | Prisma.OpenQuestionCreateWithoutClientInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutClientInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutClientInput
    | Prisma.OpenQuestionCreateOrConnectWithoutClientInput[];
  upsert?:
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutClientInput
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutClientInput[];
  createMany?: Prisma.OpenQuestionCreateManyClientInputEnvelope;
  set?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  disconnect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  delete?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  update?:
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutClientInput
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutClientInput[];
  updateMany?:
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutClientInput
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutClientInput[];
  deleteMany?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
};

export type OpenQuestionUncheckedUpdateManyWithoutClientNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutClientInput,
        Prisma.OpenQuestionUncheckedCreateWithoutClientInput
      >
    | Prisma.OpenQuestionCreateWithoutClientInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutClientInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutClientInput
    | Prisma.OpenQuestionCreateOrConnectWithoutClientInput[];
  upsert?:
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutClientInput
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutClientInput[];
  createMany?: Prisma.OpenQuestionCreateManyClientInputEnvelope;
  set?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  disconnect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  delete?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  update?:
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutClientInput
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutClientInput[];
  updateMany?:
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutClientInput
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutClientInput[];
  deleteMany?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
};

export type OpenQuestionCreateNestedManyWithoutAssigneeInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutAssigneeInput,
        Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput
      >
    | Prisma.OpenQuestionCreateWithoutAssigneeInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutAssigneeInput
    | Prisma.OpenQuestionCreateOrConnectWithoutAssigneeInput[];
  createMany?: Prisma.OpenQuestionCreateManyAssigneeInputEnvelope;
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
};

export type OpenQuestionUncheckedCreateNestedManyWithoutAssigneeInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutAssigneeInput,
        Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput
      >
    | Prisma.OpenQuestionCreateWithoutAssigneeInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutAssigneeInput
    | Prisma.OpenQuestionCreateOrConnectWithoutAssigneeInput[];
  createMany?: Prisma.OpenQuestionCreateManyAssigneeInputEnvelope;
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
};

export type OpenQuestionUpdateManyWithoutAssigneeNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutAssigneeInput,
        Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput
      >
    | Prisma.OpenQuestionCreateWithoutAssigneeInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutAssigneeInput
    | Prisma.OpenQuestionCreateOrConnectWithoutAssigneeInput[];
  upsert?:
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutAssigneeInput
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutAssigneeInput[];
  createMany?: Prisma.OpenQuestionCreateManyAssigneeInputEnvelope;
  set?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  disconnect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  delete?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  update?:
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutAssigneeInput
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutAssigneeInput[];
  updateMany?:
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutAssigneeInput
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutAssigneeInput[];
  deleteMany?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
};

export type OpenQuestionUncheckedUpdateManyWithoutAssigneeNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutAssigneeInput,
        Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput
      >
    | Prisma.OpenQuestionCreateWithoutAssigneeInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutAssigneeInput
    | Prisma.OpenQuestionCreateOrConnectWithoutAssigneeInput[];
  upsert?:
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutAssigneeInput
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutAssigneeInput[];
  createMany?: Prisma.OpenQuestionCreateManyAssigneeInputEnvelope;
  set?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  disconnect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  delete?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  update?:
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutAssigneeInput
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutAssigneeInput[];
  updateMany?:
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutAssigneeInput
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutAssigneeInput[];
  deleteMany?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
};

export type OpenQuestionCreateNestedManyWithoutMeetingInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutMeetingInput,
        Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput
      >
    | Prisma.OpenQuestionCreateWithoutMeetingInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutMeetingInput
    | Prisma.OpenQuestionCreateOrConnectWithoutMeetingInput[];
  createMany?: Prisma.OpenQuestionCreateManyMeetingInputEnvelope;
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
};

export type OpenQuestionUncheckedCreateNestedManyWithoutMeetingInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutMeetingInput,
        Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput
      >
    | Prisma.OpenQuestionCreateWithoutMeetingInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutMeetingInput
    | Prisma.OpenQuestionCreateOrConnectWithoutMeetingInput[];
  createMany?: Prisma.OpenQuestionCreateManyMeetingInputEnvelope;
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
};

export type OpenQuestionUpdateManyWithoutMeetingNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutMeetingInput,
        Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput
      >
    | Prisma.OpenQuestionCreateWithoutMeetingInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutMeetingInput
    | Prisma.OpenQuestionCreateOrConnectWithoutMeetingInput[];
  upsert?:
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutMeetingInput
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutMeetingInput[];
  createMany?: Prisma.OpenQuestionCreateManyMeetingInputEnvelope;
  set?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  disconnect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  delete?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  update?:
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutMeetingInput
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutMeetingInput[];
  updateMany?:
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutMeetingInput
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutMeetingInput[];
  deleteMany?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
};

export type OpenQuestionUncheckedUpdateManyWithoutMeetingNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutMeetingInput,
        Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput
      >
    | Prisma.OpenQuestionCreateWithoutMeetingInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutMeetingInput
    | Prisma.OpenQuestionCreateOrConnectWithoutMeetingInput[];
  upsert?:
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutMeetingInput
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutMeetingInput[];
  createMany?: Prisma.OpenQuestionCreateManyMeetingInputEnvelope;
  set?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  disconnect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  delete?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  update?:
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutMeetingInput
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutMeetingInput[];
  updateMany?:
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutMeetingInput
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutMeetingInput[];
  deleteMany?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
};

export type OpenQuestionCreateNestedManyWithoutResolvedByDecisionInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput,
        Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput
      >
    | Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionCreateOrConnectWithoutResolvedByDecisionInput[];
  createMany?: Prisma.OpenQuestionCreateManyResolvedByDecisionInputEnvelope;
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
};

export type OpenQuestionUncheckedCreateNestedManyWithoutResolvedByDecisionInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput,
        Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput
      >
    | Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionCreateOrConnectWithoutResolvedByDecisionInput[];
  createMany?: Prisma.OpenQuestionCreateManyResolvedByDecisionInputEnvelope;
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
};

export type OpenQuestionUpdateManyWithoutResolvedByDecisionNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput,
        Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput
      >
    | Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionCreateOrConnectWithoutResolvedByDecisionInput[];
  upsert?:
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutResolvedByDecisionInput[];
  createMany?: Prisma.OpenQuestionCreateManyResolvedByDecisionInputEnvelope;
  set?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  disconnect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  delete?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  update?:
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutResolvedByDecisionInput[];
  updateMany?:
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutResolvedByDecisionInput[];
  deleteMany?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
};

export type OpenQuestionUncheckedUpdateManyWithoutResolvedByDecisionNestedInput = {
  create?:
    | Prisma.XOR<
        Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput,
        Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput
      >
    | Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput[]
    | Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput[];
  connectOrCreate?:
    | Prisma.OpenQuestionCreateOrConnectWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionCreateOrConnectWithoutResolvedByDecisionInput[];
  upsert?:
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionUpsertWithWhereUniqueWithoutResolvedByDecisionInput[];
  createMany?: Prisma.OpenQuestionCreateManyResolvedByDecisionInputEnvelope;
  set?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  disconnect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  delete?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  connect?: Prisma.OpenQuestionWhereUniqueInput | Prisma.OpenQuestionWhereUniqueInput[];
  update?:
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionUpdateWithWhereUniqueWithoutResolvedByDecisionInput[];
  updateMany?:
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutResolvedByDecisionInput
    | Prisma.OpenQuestionUpdateManyWithWhereWithoutResolvedByDecisionInput[];
  deleteMany?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
};

export type EnumOpenQuestionStatusFieldUpdateOperationsInput = {
  set?: $Enums.OpenQuestionStatus;
};

export type OpenQuestionCreateWithoutClientInput = {
  id?: string;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
  meeting?: Prisma.MeetingCreateNestedOneWithoutOpenQuestionsInput;
  assignee?: Prisma.UserCreateNestedOneWithoutAssignedQuestionsInput;
  resolvedByDecision?: Prisma.DecisionCreateNestedOneWithoutResolvedQuestionsInput;
};

export type OpenQuestionUncheckedCreateWithoutClientInput = {
  id?: string;
  meetingId?: string | null;
  assigneeId?: string | null;
  resolvedByDecisionId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionCreateOrConnectWithoutClientInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.OpenQuestionCreateWithoutClientInput,
    Prisma.OpenQuestionUncheckedCreateWithoutClientInput
  >;
};

export type OpenQuestionCreateManyClientInputEnvelope = {
  data: Prisma.OpenQuestionCreateManyClientInput | Prisma.OpenQuestionCreateManyClientInput[];
  skipDuplicates?: boolean;
};

export type OpenQuestionUpsertWithWhereUniqueWithoutClientInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.OpenQuestionUpdateWithoutClientInput,
    Prisma.OpenQuestionUncheckedUpdateWithoutClientInput
  >;
  create: Prisma.XOR<
    Prisma.OpenQuestionCreateWithoutClientInput,
    Prisma.OpenQuestionUncheckedCreateWithoutClientInput
  >;
};

export type OpenQuestionUpdateWithWhereUniqueWithoutClientInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateWithoutClientInput,
    Prisma.OpenQuestionUncheckedUpdateWithoutClientInput
  >;
};

export type OpenQuestionUpdateManyWithWhereWithoutClientInput = {
  where: Prisma.OpenQuestionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateManyMutationInput,
    Prisma.OpenQuestionUncheckedUpdateManyWithoutClientInput
  >;
};

export type OpenQuestionScalarWhereInput = {
  AND?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
  OR?: Prisma.OpenQuestionScalarWhereInput[];
  NOT?: Prisma.OpenQuestionScalarWhereInput | Prisma.OpenQuestionScalarWhereInput[];
  id?: Prisma.StringFilter<'OpenQuestion'> | string;
  clientId?: Prisma.StringFilter<'OpenQuestion'> | string;
  meetingId?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
  assigneeId?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
  resolvedByDecisionId?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
  question?: Prisma.StringFilter<'OpenQuestion'> | string;
  context?: Prisma.StringNullableFilter<'OpenQuestion'> | string | null;
  status?: Prisma.EnumOpenQuestionStatusFilter<'OpenQuestion'> | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.DateTimeNullableFilter<'OpenQuestion'> | Date | string | null;
  createdAt?: Prisma.DateTimeFilter<'OpenQuestion'> | Date | string;
  resolvedAt?: Prisma.DateTimeNullableFilter<'OpenQuestion'> | Date | string | null;
};

export type OpenQuestionCreateWithoutAssigneeInput = {
  id?: string;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
  client: Prisma.ClientCreateNestedOneWithoutOpenQuestionsInput;
  meeting?: Prisma.MeetingCreateNestedOneWithoutOpenQuestionsInput;
  resolvedByDecision?: Prisma.DecisionCreateNestedOneWithoutResolvedQuestionsInput;
};

export type OpenQuestionUncheckedCreateWithoutAssigneeInput = {
  id?: string;
  clientId: string;
  meetingId?: string | null;
  resolvedByDecisionId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionCreateOrConnectWithoutAssigneeInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.OpenQuestionCreateWithoutAssigneeInput,
    Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput
  >;
};

export type OpenQuestionCreateManyAssigneeInputEnvelope = {
  data: Prisma.OpenQuestionCreateManyAssigneeInput | Prisma.OpenQuestionCreateManyAssigneeInput[];
  skipDuplicates?: boolean;
};

export type OpenQuestionUpsertWithWhereUniqueWithoutAssigneeInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.OpenQuestionUpdateWithoutAssigneeInput,
    Prisma.OpenQuestionUncheckedUpdateWithoutAssigneeInput
  >;
  create: Prisma.XOR<
    Prisma.OpenQuestionCreateWithoutAssigneeInput,
    Prisma.OpenQuestionUncheckedCreateWithoutAssigneeInput
  >;
};

export type OpenQuestionUpdateWithWhereUniqueWithoutAssigneeInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateWithoutAssigneeInput,
    Prisma.OpenQuestionUncheckedUpdateWithoutAssigneeInput
  >;
};

export type OpenQuestionUpdateManyWithWhereWithoutAssigneeInput = {
  where: Prisma.OpenQuestionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateManyMutationInput,
    Prisma.OpenQuestionUncheckedUpdateManyWithoutAssigneeInput
  >;
};

export type OpenQuestionCreateWithoutMeetingInput = {
  id?: string;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
  client: Prisma.ClientCreateNestedOneWithoutOpenQuestionsInput;
  assignee?: Prisma.UserCreateNestedOneWithoutAssignedQuestionsInput;
  resolvedByDecision?: Prisma.DecisionCreateNestedOneWithoutResolvedQuestionsInput;
};

export type OpenQuestionUncheckedCreateWithoutMeetingInput = {
  id?: string;
  clientId: string;
  assigneeId?: string | null;
  resolvedByDecisionId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionCreateOrConnectWithoutMeetingInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.OpenQuestionCreateWithoutMeetingInput,
    Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput
  >;
};

export type OpenQuestionCreateManyMeetingInputEnvelope = {
  data: Prisma.OpenQuestionCreateManyMeetingInput | Prisma.OpenQuestionCreateManyMeetingInput[];
  skipDuplicates?: boolean;
};

export type OpenQuestionUpsertWithWhereUniqueWithoutMeetingInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.OpenQuestionUpdateWithoutMeetingInput,
    Prisma.OpenQuestionUncheckedUpdateWithoutMeetingInput
  >;
  create: Prisma.XOR<
    Prisma.OpenQuestionCreateWithoutMeetingInput,
    Prisma.OpenQuestionUncheckedCreateWithoutMeetingInput
  >;
};

export type OpenQuestionUpdateWithWhereUniqueWithoutMeetingInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateWithoutMeetingInput,
    Prisma.OpenQuestionUncheckedUpdateWithoutMeetingInput
  >;
};

export type OpenQuestionUpdateManyWithWhereWithoutMeetingInput = {
  where: Prisma.OpenQuestionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateManyMutationInput,
    Prisma.OpenQuestionUncheckedUpdateManyWithoutMeetingInput
  >;
};

export type OpenQuestionCreateWithoutResolvedByDecisionInput = {
  id?: string;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
  client: Prisma.ClientCreateNestedOneWithoutOpenQuestionsInput;
  meeting?: Prisma.MeetingCreateNestedOneWithoutOpenQuestionsInput;
  assignee?: Prisma.UserCreateNestedOneWithoutAssignedQuestionsInput;
};

export type OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput = {
  id?: string;
  clientId: string;
  meetingId?: string | null;
  assigneeId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionCreateOrConnectWithoutResolvedByDecisionInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput,
    Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput
  >;
};

export type OpenQuestionCreateManyResolvedByDecisionInputEnvelope = {
  data:
    | Prisma.OpenQuestionCreateManyResolvedByDecisionInput
    | Prisma.OpenQuestionCreateManyResolvedByDecisionInput[];
  skipDuplicates?: boolean;
};

export type OpenQuestionUpsertWithWhereUniqueWithoutResolvedByDecisionInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.OpenQuestionUpdateWithoutResolvedByDecisionInput,
    Prisma.OpenQuestionUncheckedUpdateWithoutResolvedByDecisionInput
  >;
  create: Prisma.XOR<
    Prisma.OpenQuestionCreateWithoutResolvedByDecisionInput,
    Prisma.OpenQuestionUncheckedCreateWithoutResolvedByDecisionInput
  >;
};

export type OpenQuestionUpdateWithWhereUniqueWithoutResolvedByDecisionInput = {
  where: Prisma.OpenQuestionWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateWithoutResolvedByDecisionInput,
    Prisma.OpenQuestionUncheckedUpdateWithoutResolvedByDecisionInput
  >;
};

export type OpenQuestionUpdateManyWithWhereWithoutResolvedByDecisionInput = {
  where: Prisma.OpenQuestionScalarWhereInput;
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateManyMutationInput,
    Prisma.OpenQuestionUncheckedUpdateManyWithoutResolvedByDecisionInput
  >;
};

export type OpenQuestionCreateManyClientInput = {
  id?: string;
  meetingId?: string | null;
  assigneeId?: string | null;
  resolvedByDecisionId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionUpdateWithoutClientInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  meeting?: Prisma.MeetingUpdateOneWithoutOpenQuestionsNestedInput;
  assignee?: Prisma.UserUpdateOneWithoutAssignedQuestionsNestedInput;
  resolvedByDecision?: Prisma.DecisionUpdateOneWithoutResolvedQuestionsNestedInput;
};

export type OpenQuestionUncheckedUpdateWithoutClientInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  meetingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  assigneeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  resolvedByDecisionId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionUncheckedUpdateManyWithoutClientInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  meetingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  assigneeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  resolvedByDecisionId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionCreateManyAssigneeInput = {
  id?: string;
  clientId: string;
  meetingId?: string | null;
  resolvedByDecisionId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionUpdateWithoutAssigneeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  client?: Prisma.ClientUpdateOneRequiredWithoutOpenQuestionsNestedInput;
  meeting?: Prisma.MeetingUpdateOneWithoutOpenQuestionsNestedInput;
  resolvedByDecision?: Prisma.DecisionUpdateOneWithoutResolvedQuestionsNestedInput;
};

export type OpenQuestionUncheckedUpdateWithoutAssigneeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  clientId?: Prisma.StringFieldUpdateOperationsInput | string;
  meetingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  resolvedByDecisionId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionUncheckedUpdateManyWithoutAssigneeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  clientId?: Prisma.StringFieldUpdateOperationsInput | string;
  meetingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  resolvedByDecisionId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionCreateManyMeetingInput = {
  id?: string;
  clientId: string;
  assigneeId?: string | null;
  resolvedByDecisionId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionUpdateWithoutMeetingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  client?: Prisma.ClientUpdateOneRequiredWithoutOpenQuestionsNestedInput;
  assignee?: Prisma.UserUpdateOneWithoutAssignedQuestionsNestedInput;
  resolvedByDecision?: Prisma.DecisionUpdateOneWithoutResolvedQuestionsNestedInput;
};

export type OpenQuestionUncheckedUpdateWithoutMeetingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  clientId?: Prisma.StringFieldUpdateOperationsInput | string;
  assigneeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  resolvedByDecisionId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionUncheckedUpdateManyWithoutMeetingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  clientId?: Prisma.StringFieldUpdateOperationsInput | string;
  assigneeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  resolvedByDecisionId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionCreateManyResolvedByDecisionInput = {
  id?: string;
  clientId: string;
  meetingId?: string | null;
  assigneeId?: string | null;
  question: string;
  context?: string | null;
  status?: $Enums.OpenQuestionStatus;
  dueAt?: Date | string | null;
  createdAt?: Date | string;
  resolvedAt?: Date | string | null;
};

export type OpenQuestionUpdateWithoutResolvedByDecisionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  client?: Prisma.ClientUpdateOneRequiredWithoutOpenQuestionsNestedInput;
  meeting?: Prisma.MeetingUpdateOneWithoutOpenQuestionsNestedInput;
  assignee?: Prisma.UserUpdateOneWithoutAssignedQuestionsNestedInput;
};

export type OpenQuestionUncheckedUpdateWithoutResolvedByDecisionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  clientId?: Prisma.StringFieldUpdateOperationsInput | string;
  meetingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  assigneeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionUncheckedUpdateManyWithoutResolvedByDecisionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  clientId?: Prisma.StringFieldUpdateOperationsInput | string;
  meetingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  assigneeId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  question?: Prisma.StringFieldUpdateOperationsInput | string;
  context?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  status?: Prisma.EnumOpenQuestionStatusFieldUpdateOperationsInput | $Enums.OpenQuestionStatus;
  dueAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  resolvedAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
};

export type OpenQuestionSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    clientId?: boolean;
    meetingId?: boolean;
    assigneeId?: boolean;
    resolvedByDecisionId?: boolean;
    question?: boolean;
    context?: boolean;
    status?: boolean;
    dueAt?: boolean;
    createdAt?: boolean;
    resolvedAt?: boolean;
    client?: boolean | Prisma.ClientDefaultArgs<ExtArgs>;
    meeting?: boolean | Prisma.OpenQuestion$meetingArgs<ExtArgs>;
    assignee?: boolean | Prisma.OpenQuestion$assigneeArgs<ExtArgs>;
    resolvedByDecision?: boolean | Prisma.OpenQuestion$resolvedByDecisionArgs<ExtArgs>;
  },
  ExtArgs['result']['openQuestion']
>;

export type OpenQuestionSelectCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    clientId?: boolean;
    meetingId?: boolean;
    assigneeId?: boolean;
    resolvedByDecisionId?: boolean;
    question?: boolean;
    context?: boolean;
    status?: boolean;
    dueAt?: boolean;
    createdAt?: boolean;
    resolvedAt?: boolean;
    client?: boolean | Prisma.ClientDefaultArgs<ExtArgs>;
    meeting?: boolean | Prisma.OpenQuestion$meetingArgs<ExtArgs>;
    assignee?: boolean | Prisma.OpenQuestion$assigneeArgs<ExtArgs>;
    resolvedByDecision?: boolean | Prisma.OpenQuestion$resolvedByDecisionArgs<ExtArgs>;
  },
  ExtArgs['result']['openQuestion']
>;

export type OpenQuestionSelectUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    clientId?: boolean;
    meetingId?: boolean;
    assigneeId?: boolean;
    resolvedByDecisionId?: boolean;
    question?: boolean;
    context?: boolean;
    status?: boolean;
    dueAt?: boolean;
    createdAt?: boolean;
    resolvedAt?: boolean;
    client?: boolean | Prisma.ClientDefaultArgs<ExtArgs>;
    meeting?: boolean | Prisma.OpenQuestion$meetingArgs<ExtArgs>;
    assignee?: boolean | Prisma.OpenQuestion$assigneeArgs<ExtArgs>;
    resolvedByDecision?: boolean | Prisma.OpenQuestion$resolvedByDecisionArgs<ExtArgs>;
  },
  ExtArgs['result']['openQuestion']
>;

export type OpenQuestionSelectScalar = {
  id?: boolean;
  clientId?: boolean;
  meetingId?: boolean;
  assigneeId?: boolean;
  resolvedByDecisionId?: boolean;
  question?: boolean;
  context?: boolean;
  status?: boolean;
  dueAt?: boolean;
  createdAt?: boolean;
  resolvedAt?: boolean;
};

export type OpenQuestionOmit<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  | 'id'
  | 'clientId'
  | 'meetingId'
  | 'assigneeId'
  | 'resolvedByDecisionId'
  | 'question'
  | 'context'
  | 'status'
  | 'dueAt'
  | 'createdAt'
  | 'resolvedAt',
  ExtArgs['result']['openQuestion']
>;
export type OpenQuestionInclude<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  client?: boolean | Prisma.ClientDefaultArgs<ExtArgs>;
  meeting?: boolean | Prisma.OpenQuestion$meetingArgs<ExtArgs>;
  assignee?: boolean | Prisma.OpenQuestion$assigneeArgs<ExtArgs>;
  resolvedByDecision?: boolean | Prisma.OpenQuestion$resolvedByDecisionArgs<ExtArgs>;
};
export type OpenQuestionIncludeCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  client?: boolean | Prisma.ClientDefaultArgs<ExtArgs>;
  meeting?: boolean | Prisma.OpenQuestion$meetingArgs<ExtArgs>;
  assignee?: boolean | Prisma.OpenQuestion$assigneeArgs<ExtArgs>;
  resolvedByDecision?: boolean | Prisma.OpenQuestion$resolvedByDecisionArgs<ExtArgs>;
};
export type OpenQuestionIncludeUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  client?: boolean | Prisma.ClientDefaultArgs<ExtArgs>;
  meeting?: boolean | Prisma.OpenQuestion$meetingArgs<ExtArgs>;
  assignee?: boolean | Prisma.OpenQuestion$assigneeArgs<ExtArgs>;
  resolvedByDecision?: boolean | Prisma.OpenQuestion$resolvedByDecisionArgs<ExtArgs>;
};

export type $OpenQuestionPayload<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  name: 'OpenQuestion';
  objects: {
    client: Prisma.$ClientPayload<ExtArgs>;
    meeting: Prisma.$MeetingPayload<ExtArgs> | null;
    assignee: Prisma.$UserPayload<ExtArgs> | null;
    resolvedByDecision: Prisma.$DecisionPayload<ExtArgs> | null;
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string;
      clientId: string;
      meetingId: string | null;
      assigneeId: string | null;
      resolvedByDecisionId: string | null;
      question: string;
      context: string | null;
      status: $Enums.OpenQuestionStatus;
      dueAt: Date | null;
      createdAt: Date;
      resolvedAt: Date | null;
    },
    ExtArgs['result']['openQuestion']
  >;
  composites: {};
};

export type OpenQuestionGetPayload<S extends boolean | null | undefined | OpenQuestionDefaultArgs> =
  runtime.Types.Result.GetResult<Prisma.$OpenQuestionPayload, S>;

export type OpenQuestionCountArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<OpenQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
  select?: OpenQuestionCountAggregateInputType | true;
};

export interface OpenQuestionDelegate<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: {
    types: Prisma.TypeMap<ExtArgs>['model']['OpenQuestion'];
    meta: { name: 'OpenQuestion' };
  };
  /**
   * Find zero or one OpenQuestion that matches the filter.
   * @param {OpenQuestionFindUniqueArgs} args - Arguments to find a OpenQuestion
   * @example
   * // Get one OpenQuestion
   * const openQuestion = await prisma.openQuestion.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends OpenQuestionFindUniqueArgs>(
    args: Prisma.SelectSubset<T, OpenQuestionFindUniqueArgs<ExtArgs>>
  ): Prisma.Prisma__OpenQuestionClient<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'findUnique',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one OpenQuestion that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {OpenQuestionFindUniqueOrThrowArgs} args - Arguments to find a OpenQuestion
   * @example
   * // Get one OpenQuestion
   * const openQuestion = await prisma.openQuestion.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends OpenQuestionFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, OpenQuestionFindUniqueOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__OpenQuestionClient<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'findUniqueOrThrow',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first OpenQuestion that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OpenQuestionFindFirstArgs} args - Arguments to find a OpenQuestion
   * @example
   * // Get one OpenQuestion
   * const openQuestion = await prisma.openQuestion.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends OpenQuestionFindFirstArgs>(
    args?: Prisma.SelectSubset<T, OpenQuestionFindFirstArgs<ExtArgs>>
  ): Prisma.Prisma__OpenQuestionClient<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'findFirst',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first OpenQuestion that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OpenQuestionFindFirstOrThrowArgs} args - Arguments to find a OpenQuestion
   * @example
   * // Get one OpenQuestion
   * const openQuestion = await prisma.openQuestion.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends OpenQuestionFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, OpenQuestionFindFirstOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__OpenQuestionClient<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'findFirstOrThrow',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more OpenQuestions that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OpenQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all OpenQuestions
   * const openQuestions = await prisma.openQuestion.findMany()
   *
   * // Get first 10 OpenQuestions
   * const openQuestions = await prisma.openQuestion.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const openQuestionWithIdOnly = await prisma.openQuestion.findMany({ select: { id: true } })
   *
   */
  findMany<T extends OpenQuestionFindManyArgs>(
    args?: Prisma.SelectSubset<T, OpenQuestionFindManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'findMany',
      GlobalOmitOptions
    >
  >;

  /**
   * Create a OpenQuestion.
   * @param {OpenQuestionCreateArgs} args - Arguments to create a OpenQuestion.
   * @example
   * // Create one OpenQuestion
   * const OpenQuestion = await prisma.openQuestion.create({
   *   data: {
   *     // ... data to create a OpenQuestion
   *   }
   * })
   *
   */
  create<T extends OpenQuestionCreateArgs>(
    args: Prisma.SelectSubset<T, OpenQuestionCreateArgs<ExtArgs>>
  ): Prisma.Prisma__OpenQuestionClient<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'create',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many OpenQuestions.
   * @param {OpenQuestionCreateManyArgs} args - Arguments to create many OpenQuestions.
   * @example
   * // Create many OpenQuestions
   * const openQuestion = await prisma.openQuestion.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends OpenQuestionCreateManyArgs>(
    args?: Prisma.SelectSubset<T, OpenQuestionCreateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many OpenQuestions and returns the data saved in the database.
   * @param {OpenQuestionCreateManyAndReturnArgs} args - Arguments to create many OpenQuestions.
   * @example
   * // Create many OpenQuestions
   * const openQuestion = await prisma.openQuestion.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many OpenQuestions and only return the `id`
   * const openQuestionWithIdOnly = await prisma.openQuestion.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends OpenQuestionCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, OpenQuestionCreateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'createManyAndReturn',
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a OpenQuestion.
   * @param {OpenQuestionDeleteArgs} args - Arguments to delete one OpenQuestion.
   * @example
   * // Delete one OpenQuestion
   * const OpenQuestion = await prisma.openQuestion.delete({
   *   where: {
   *     // ... filter to delete one OpenQuestion
   *   }
   * })
   *
   */
  delete<T extends OpenQuestionDeleteArgs>(
    args: Prisma.SelectSubset<T, OpenQuestionDeleteArgs<ExtArgs>>
  ): Prisma.Prisma__OpenQuestionClient<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'delete',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one OpenQuestion.
   * @param {OpenQuestionUpdateArgs} args - Arguments to update one OpenQuestion.
   * @example
   * // Update one OpenQuestion
   * const openQuestion = await prisma.openQuestion.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends OpenQuestionUpdateArgs>(
    args: Prisma.SelectSubset<T, OpenQuestionUpdateArgs<ExtArgs>>
  ): Prisma.Prisma__OpenQuestionClient<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'update',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more OpenQuestions.
   * @param {OpenQuestionDeleteManyArgs} args - Arguments to filter OpenQuestions to delete.
   * @example
   * // Delete a few OpenQuestions
   * const { count } = await prisma.openQuestion.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends OpenQuestionDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, OpenQuestionDeleteManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more OpenQuestions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OpenQuestionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many OpenQuestions
   * const openQuestion = await prisma.openQuestion.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends OpenQuestionUpdateManyArgs>(
    args: Prisma.SelectSubset<T, OpenQuestionUpdateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more OpenQuestions and returns the data updated in the database.
   * @param {OpenQuestionUpdateManyAndReturnArgs} args - Arguments to update many OpenQuestions.
   * @example
   * // Update many OpenQuestions
   * const openQuestion = await prisma.openQuestion.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more OpenQuestions and only return the `id`
   * const openQuestionWithIdOnly = await prisma.openQuestion.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends OpenQuestionUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, OpenQuestionUpdateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'updateManyAndReturn',
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one OpenQuestion.
   * @param {OpenQuestionUpsertArgs} args - Arguments to update or create a OpenQuestion.
   * @example
   * // Update or create a OpenQuestion
   * const openQuestion = await prisma.openQuestion.upsert({
   *   create: {
   *     // ... data to create a OpenQuestion
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the OpenQuestion we want to update
   *   }
   * })
   */
  upsert<T extends OpenQuestionUpsertArgs>(
    args: Prisma.SelectSubset<T, OpenQuestionUpsertArgs<ExtArgs>>
  ): Prisma.Prisma__OpenQuestionClient<
    runtime.Types.Result.GetResult<
      Prisma.$OpenQuestionPayload<ExtArgs>,
      T,
      'upsert',
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of OpenQuestions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OpenQuestionCountArgs} args - Arguments to filter OpenQuestions to count.
   * @example
   * // Count the number of OpenQuestions
   * const count = await prisma.openQuestion.count({
   *   where: {
   *     // ... the filter for the OpenQuestions we want to count
   *   }
   * })
   **/
  count<T extends OpenQuestionCountArgs>(
    args?: Prisma.Subset<T, OpenQuestionCountArgs>
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], OpenQuestionCountAggregateOutputType>
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a OpenQuestion.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OpenQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends OpenQuestionAggregateArgs>(
    args: Prisma.Subset<T, OpenQuestionAggregateArgs>
  ): Prisma.PrismaPromise<GetOpenQuestionAggregateType<T>>;

  /**
   * Group by OpenQuestion.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {OpenQuestionGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends OpenQuestionGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: OpenQuestionGroupByArgs['orderBy'] }
      : { orderBy?: OpenQuestionGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<
      Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
    >,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
          }[HavingFields]
        : 'take' extends Prisma.Keys<T>
          ? 'orderBy' extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : 'skip' extends Prisma.Keys<T>
            ? 'orderBy' extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, OpenQuestionGroupByArgs, OrderByArg> & InputErrors
  ): {} extends InputErrors ? GetOpenQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the OpenQuestion model
   */
  readonly fields: OpenQuestionFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for OpenQuestion.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__OpenQuestionClient<
  T,
  Null = never,
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: 'PrismaPromise';
  client<T extends Prisma.ClientDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.ClientDefaultArgs<ExtArgs>>
  ): Prisma.Prisma__ClientClient<
    | runtime.Types.Result.GetResult<
        Prisma.$ClientPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  meeting<T extends Prisma.OpenQuestion$meetingArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.OpenQuestion$meetingArgs<ExtArgs>>
  ): Prisma.Prisma__MeetingClient<
    runtime.Types.Result.GetResult<
      Prisma.$MeetingPayload<ExtArgs>,
      T,
      'findUniqueOrThrow',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  assignee<T extends Prisma.OpenQuestion$assigneeArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.OpenQuestion$assigneeArgs<ExtArgs>>
  ): Prisma.Prisma__UserClient<
    runtime.Types.Result.GetResult<
      Prisma.$UserPayload<ExtArgs>,
      T,
      'findUniqueOrThrow',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  resolvedByDecision<T extends Prisma.OpenQuestion$resolvedByDecisionArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.OpenQuestion$resolvedByDecisionArgs<ExtArgs>>
  ): Prisma.Prisma__DecisionClient<
    runtime.Types.Result.GetResult<
      Prisma.$DecisionPayload<ExtArgs>,
      T,
      'findUniqueOrThrow',
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the OpenQuestion model
 */
export interface OpenQuestionFieldRefs {
  readonly id: Prisma.FieldRef<'OpenQuestion', 'String'>;
  readonly clientId: Prisma.FieldRef<'OpenQuestion', 'String'>;
  readonly meetingId: Prisma.FieldRef<'OpenQuestion', 'String'>;
  readonly assigneeId: Prisma.FieldRef<'OpenQuestion', 'String'>;
  readonly resolvedByDecisionId: Prisma.FieldRef<'OpenQuestion', 'String'>;
  readonly question: Prisma.FieldRef<'OpenQuestion', 'String'>;
  readonly context: Prisma.FieldRef<'OpenQuestion', 'String'>;
  readonly status: Prisma.FieldRef<'OpenQuestion', 'OpenQuestionStatus'>;
  readonly dueAt: Prisma.FieldRef<'OpenQuestion', 'DateTime'>;
  readonly createdAt: Prisma.FieldRef<'OpenQuestion', 'DateTime'>;
  readonly resolvedAt: Prisma.FieldRef<'OpenQuestion', 'DateTime'>;
}

// Custom InputTypes
/**
 * OpenQuestion findUnique
 */
export type OpenQuestionFindUniqueArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
  /**
   * Filter, which OpenQuestion to fetch.
   */
  where: Prisma.OpenQuestionWhereUniqueInput;
};

/**
 * OpenQuestion findUniqueOrThrow
 */
export type OpenQuestionFindUniqueOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
  /**
   * Filter, which OpenQuestion to fetch.
   */
  where: Prisma.OpenQuestionWhereUniqueInput;
};

/**
 * OpenQuestion findFirst
 */
export type OpenQuestionFindFirstArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
  /**
   * Filter, which OpenQuestion to fetch.
   */
  where?: Prisma.OpenQuestionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of OpenQuestions to fetch.
   */
  orderBy?:
    | Prisma.OpenQuestionOrderByWithRelationInput
    | Prisma.OpenQuestionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for OpenQuestions.
   */
  cursor?: Prisma.OpenQuestionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` OpenQuestions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` OpenQuestions.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of OpenQuestions.
   */
  distinct?: Prisma.OpenQuestionScalarFieldEnum | Prisma.OpenQuestionScalarFieldEnum[];
};

/**
 * OpenQuestion findFirstOrThrow
 */
export type OpenQuestionFindFirstOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
  /**
   * Filter, which OpenQuestion to fetch.
   */
  where?: Prisma.OpenQuestionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of OpenQuestions to fetch.
   */
  orderBy?:
    | Prisma.OpenQuestionOrderByWithRelationInput
    | Prisma.OpenQuestionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for OpenQuestions.
   */
  cursor?: Prisma.OpenQuestionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` OpenQuestions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` OpenQuestions.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of OpenQuestions.
   */
  distinct?: Prisma.OpenQuestionScalarFieldEnum | Prisma.OpenQuestionScalarFieldEnum[];
};

/**
 * OpenQuestion findMany
 */
export type OpenQuestionFindManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
  /**
   * Filter, which OpenQuestions to fetch.
   */
  where?: Prisma.OpenQuestionWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of OpenQuestions to fetch.
   */
  orderBy?:
    | Prisma.OpenQuestionOrderByWithRelationInput
    | Prisma.OpenQuestionOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing OpenQuestions.
   */
  cursor?: Prisma.OpenQuestionWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` OpenQuestions from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` OpenQuestions.
   */
  skip?: number;
  distinct?: Prisma.OpenQuestionScalarFieldEnum | Prisma.OpenQuestionScalarFieldEnum[];
};

/**
 * OpenQuestion create
 */
export type OpenQuestionCreateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
  /**
   * The data needed to create a OpenQuestion.
   */
  data: Prisma.XOR<Prisma.OpenQuestionCreateInput, Prisma.OpenQuestionUncheckedCreateInput>;
};

/**
 * OpenQuestion createMany
 */
export type OpenQuestionCreateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many OpenQuestions.
   */
  data: Prisma.OpenQuestionCreateManyInput | Prisma.OpenQuestionCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * OpenQuestion createManyAndReturn
 */
export type OpenQuestionCreateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * The data used to create many OpenQuestions.
   */
  data: Prisma.OpenQuestionCreateManyInput | Prisma.OpenQuestionCreateManyInput[];
  skipDuplicates?: boolean;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * OpenQuestion update
 */
export type OpenQuestionUpdateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
  /**
   * The data needed to update a OpenQuestion.
   */
  data: Prisma.XOR<Prisma.OpenQuestionUpdateInput, Prisma.OpenQuestionUncheckedUpdateInput>;
  /**
   * Choose, which OpenQuestion to update.
   */
  where: Prisma.OpenQuestionWhereUniqueInput;
};

/**
 * OpenQuestion updateMany
 */
export type OpenQuestionUpdateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update OpenQuestions.
   */
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateManyMutationInput,
    Prisma.OpenQuestionUncheckedUpdateManyInput
  >;
  /**
   * Filter which OpenQuestions to update
   */
  where?: Prisma.OpenQuestionWhereInput;
  /**
   * Limit how many OpenQuestions to update.
   */
  limit?: number;
};

/**
 * OpenQuestion updateManyAndReturn
 */
export type OpenQuestionUpdateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * The data used to update OpenQuestions.
   */
  data: Prisma.XOR<
    Prisma.OpenQuestionUpdateManyMutationInput,
    Prisma.OpenQuestionUncheckedUpdateManyInput
  >;
  /**
   * Filter which OpenQuestions to update
   */
  where?: Prisma.OpenQuestionWhereInput;
  /**
   * Limit how many OpenQuestions to update.
   */
  limit?: number;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * OpenQuestion upsert
 */
export type OpenQuestionUpsertArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
  /**
   * The filter to search for the OpenQuestion to update in case it exists.
   */
  where: Prisma.OpenQuestionWhereUniqueInput;
  /**
   * In case the OpenQuestion found by the `where` argument doesn't exist, create a new OpenQuestion with this data.
   */
  create: Prisma.XOR<Prisma.OpenQuestionCreateInput, Prisma.OpenQuestionUncheckedCreateInput>;
  /**
   * In case the OpenQuestion was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.OpenQuestionUpdateInput, Prisma.OpenQuestionUncheckedUpdateInput>;
};

/**
 * OpenQuestion delete
 */
export type OpenQuestionDeleteArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
  /**
   * Filter which OpenQuestion to delete.
   */
  where: Prisma.OpenQuestionWhereUniqueInput;
};

/**
 * OpenQuestion deleteMany
 */
export type OpenQuestionDeleteManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which OpenQuestions to delete
   */
  where?: Prisma.OpenQuestionWhereInput;
  /**
   * Limit how many OpenQuestions to delete.
   */
  limit?: number;
};

/**
 * OpenQuestion.meeting
 */
export type OpenQuestion$meetingArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Meeting
   */
  select?: Prisma.MeetingSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Meeting
   */
  omit?: Prisma.MeetingOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MeetingInclude<ExtArgs> | null;
  where?: Prisma.MeetingWhereInput;
};

/**
 * OpenQuestion.assignee
 */
export type OpenQuestion$assigneeArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null;
  where?: Prisma.UserWhereInput;
};

/**
 * OpenQuestion.resolvedByDecision
 */
export type OpenQuestion$resolvedByDecisionArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Decision
   */
  select?: Prisma.DecisionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Decision
   */
  omit?: Prisma.DecisionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DecisionInclude<ExtArgs> | null;
  where?: Prisma.DecisionWhereInput;
};

/**
 * OpenQuestion without action
 */
export type OpenQuestionDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the OpenQuestion
   */
  select?: Prisma.OpenQuestionSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the OpenQuestion
   */
  omit?: Prisma.OpenQuestionOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.OpenQuestionInclude<ExtArgs> | null;
};
